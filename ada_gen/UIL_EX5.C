#include <math.h>
#include <stdlib.h>
/*=========================================================================*/
/*  This program illustrates the use of the strip chart routines available */
/*  in the User Interface Library.                                         */
/*=========================================================================*/

#include <stdio.h>
#include "dac_adc.h"

FILE *f;
int nk,act,BufTik;
float freq;
int iniTime=3;
unsigned long nr,tik;
fpos_t pos;

#define CHANNEL 32
#define BufferLen 4000

int isFull[3],isOverflow=0,AlertBuffer=1;
float *Buffer[3][CHANNEL];
float SentBuf[CHANNEL],RecvBuf[CHANNEL];
float PassiveBuf[CHANNEL];

double ShowBufDAC[CHANNEL],ShowBufADC[CHANNEL];

/*= INCLUDES ==============================================================*/
/*                                                                         */
/*  Remember, never modify the contents of include files generated by the  */
/*  User Interface Editor.                                                 */
/*=========================================================================*/

#include <userint.h>
#include <formatio.h>
#include <lwsystem.h>
#include "uil_ex5.h"

/*= DEFINES ===============================================================*/

#define  TRUE   1
#define  FALSE  0

/*= FUNCTION DECLARATIONS =================================================*/

void UpdateBuffers(void);
void interrupt hook(void);
int Enable(float);
int Disable(void);
void doRewind(float Freq,unsigned int Tm,unsigned int Chl, float *valB, float *valE);

/*= MAIN PROGRAM ==========================================================*/

void main (int argc, char *argv[])

{
  int id,panel_hdl,start,handle,i,k;

  if(DrvInitialize()!=DRV_OK) { printf("UPI's driver can't installed.\n"); return; }

  /*-----------------------------------------------------------------------*/
  /*  Load the panel from the resource file.  Use the constant assigned    */
  /*  in the editor to refer to the panel.  The handle returned by         */
  /*  LoadPanel must be used to reference the panel in all subsequent      */
  /*  function calls. If the panel handle is negative, the panel failed,   */
  /*  so print a message and exit the program.  Otherwise, display the     */
  /*  panel.                                                               */
  /*-----------------------------------------------------------------------*/
  f=fopen(argv[1],"r+t");
  if(!f) { printf("Invalid file <%s>\n",argv[1] ? argv[1]:""); return; }
  fscanf(f,"%d %f %ld",&nk,&freq,&nr);
  fgetpos(f,&pos);

  for(i=0;i<3;i++)
    {
    for(k=0;k<nk;k++)
      {
      Buffer[i][k]=calloc(BufferLen,sizeof(float));
      if(!Buffer[i][k]) { printf("Too low memory.\n"); return; }
      }
    }


  panel_hdl = LoadPanel("uil_ex5.uir",VM);
  if (panel_hdl < 0) {
    FmtOut("Unable to load the required panel from the resource file.\n");
    return;
  }
  DisplayPanel(panel_hdl);

  act=2; UpdateBuffers();
  act=0; BufTik=0;
  start = FALSE;

  while (TRUE) {
    /*---------------------------------------------------------------------*/
    /*  Call GetUserEvent with the wait parameter set to FALSE. This will  */
    /*  cause the function to return immediately without waiting for an    */
    /*  event.  If an event occurred, the id variable will match one of    */
    /*  the control ID constants assigned in the editor.  Since we only    */
    /*  have one panel loaded, we do not have to examine the handle value  */
    /*  returned by GetUserEvent.                                          */
    /*---------------------------------------------------------------------*/
    GetUserEvent(FALSE,&handle,&id);
    switch (id) {
      case VM_START :
        start = TRUE;
        DrvSetChannel(nk,nk);
        DrvSetHook(hook);
        Enable(freq);
        break;
      case VM_STOP :
        Disable();
        start = FALSE;
        break;
      case VM_RESET :
        DeletePlots(panel_hdl,VM_INPUTS);
        DeletePlots(panel_hdl,VM_AVERAGE);
        //      SetTraceAttribute(panel_hdl,VM_AVERAGE,1,1,0);
        fseek(f,pos,SEEK_SET); tik=0;
        break;
      case VM_QUIT :
        Disable();
        goto done;
    }
    /*---------------------------------------------------------------------*/
    if(start)
      {
      int ret;
      
      DrvWaitDAC_ADC();
      UpdateBuffers();
      for(i=0;i<nk;i++)
         {
         ShowBufDAC[i]=SentBuf[i];
         ShowBufADC[i]=RecvBuf[i];
         }
      ret=PlotStripChart(panel_hdl,VM_INPUTS,ShowBufDAC,nk,0,0,4);
      ret=PlotStripChart(panel_hdl,VM_AVERAGE,ShowBufADC,nk,0,0,4);
      if(isOverflow)
        {
        /*--------- Alert: Need currently filling buffer ----------------- */
        }
      }
  }
done:
 fclose(f);
 DrvDeinitialize();
}

void UpdateBuffers(void)
{
 int i,k,m;
 long l;

 for(i=1;i<3;i++)
   {
   k=(act+i)%3;
   if(!isFull[k])
     {
     AlertBuffer=k;
     for(l=0;l<BufferLen;l++)
       {
       for(m=0;m<nk;m++)
         { fscanf(f,"%f",&Buffer[k][m][l]); Buffer[k][m][l]/=5; } tik++;
       if(tik>nr) { fseek(f,pos,SEEK_SET); tik=0; }
       }
     isFull[k]=TRUE;
     }
   }
 AlertBuffer=-1;
 return;
}

void interrupt hook(void)
{
 register int i;

 if(act==AlertBuffer) isOverflow=TRUE;
 else
   {
   isOverflow=0;
   for(i=0;i<nk;i++) SentBuf[i]=Buffer[act][i][BufTik];
   BufTik=(BufTik+1)%BufferLen;
   if(!BufTik) act=(act+1)%3;

   DrvSetVolDAC(SentBuf);
   }

 return;
}


int Enable(float freq)
{
 int i,ret;
 float buf[CHANNEL];

 ret=DrvEnable(freq);
 if(ret==DRV_OK)
   {
   DrvGetVolDAC(PassiveBuf);
   for(i=0;i<nk;i++) buf[i]=Buffer[act][i][0];

   doRewind(freq,iniTime,nk,PassiveBuf,buf);
   }
 return ret;
}

int Disable(void)
{
 float buf[CHANNEL];

 DrvGetVolDAC(buf);
 doRewind(freq,iniTime,nk,buf,PassiveBuf);

 DrvDisable();
}

